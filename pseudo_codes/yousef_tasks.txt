# Tasks Description:
	1. Write a UNIX command line interpreter.
		Your Shell should:
			- Display a prompt and wait for the user to type a command. A command line always ends with a new line.
			- The command lines are simple, no semicolons, no pipes, no redirections or any other advanced features.
			- The command lines are made only of one word. No arguments will be passed to programs.
			- If an executable cannot be found, print an error message and display the prompt again.
			- Handle errors.
			- You have to handle the “end of file” condition (Ctrl+D).
	2. Handle command lines with arguments.
	3. Implement the exit built-in, that exits the shell.
	4. Write your own getline function.
	5. Handle arguments for the built-in exit.
	6. Implement the builtin command cd.
	7. Handle variables replacement.
		
		
	
Pseudocode
----------	
function name: _putchar_f
location: _putchar_f.c file
description: writes the character c to stdout

Steps:
	- Write a given character to standard output (stdout).


Pseudocode
----------	
function name: _putchar_f
location: _putchar_f.c file
description: writes a string to stdout

Steps:
	1. Start a loop while the current character pointed by str is not the null terminator '\0':
		a. Print the current character using the `_putchar_f` function.
		b. Increment the str pointer to the next character in the string.
	2. End of loop
	
	
Pseudocode
----------	
function name: prompt_f
location: prompt_f.c file
description: prints @ to standard output.

Steps:
	- invokes _puts_f function given "@ " as an argument.


Pseudocode
----------	
function name: tokenize_f
location: read_f.c file
description: tokenize a string with a specific delimiter

Steps:
		1. Declare variables: token_v (char pointer).
		2. Set cnt_v variable to 0.
		3. Tokenize the copied string using strtok function with input_v and delimiter.
		4. Initialize tokens_v variable to NULL.
		5. Start a loop while token_v is not NULL:
		   a. Reallocate memory for tokens_v to accommodate the new token (cnt_v + 1) * sizeof(char *).
		   b. If the memory allocation fails, free input_v, free tokens_v, and print an error message.
		   c. Allocate memory for tokens_v[cnt_v] to store the token (strlen(token_v) + 1) * sizeof(char).
		   d. If the memory allocation fails, free input_v, free tokens_v, and print an error message.
		   e. Copy the token string to tokens_v[cnt_v] using _strcpy_f function.
		   f. Update token_v using strtok function with NULL and delimiter to get the next token.
		   g. Increment cnt_v by 1.
		6. End of loop.


Pseudocode
----------	
function name: execute_f
location: execute_f.c file
description: Executes a command with the given arguments.

Steps:
	1. Declare a variable id_v of type pid_t.
	2. Fork a new process using fork() and assign the return value to id_v.
	3. Check if id_v is 0, indicating that this code is running in the child process:
	   a. Attempt to execute the command with the given path name and arguments using execve().
	4. If id_v is -1, an error occurred while forking:
	   a. Print an error message using perror().
	   b. Exit the program with a failure status using exit(EXIT_FAILURE).
	5. Otherwise, id_v is positive, indicating that this code is running in the parent process:
	   a. Wait for the child process to complete using wait(NULL).
	6. End of function.
	
	
Pseudocode
----------	
function name: _getline_f
location: _getline_f.c file
description: Function: _getline_f
Description: Reads an entire line from a stream with error handling and dynamic resizing of the buffer.

Steps:
	1. Declare variables: bytes_read_v (int), i (int), j (int).
	2. Check if *n is 0 or *lineptr is NULL:
	   a. If true, allocate memory for *lineptr with initial size BUFFER_SIZE.
	   b. If the allocation fails, return -1 to indicate a memory allocation error.
	3. Start an infinite loop:
	   a. Check if j is greater than or equal to bytes_read_v.
		  - If true, read data from the stream into buffer_v with a constant buffer size of BUFFER_SIZE.
		  - Reset j to 0.
	   b. Check if bytes_read_v is 0 or -1.
		  - If true, return -1 to indicate an error or EOF.
	   c. Check if i is greater than *n.
		  - If true, increase the size of *lineptr by BUFFER_SIZE using realloc().
		  - If the reallocation fails, return -1 to indicate a memory allocation error.
	   d. Check if buffer_v[j] is the newline character '\n'.
		  - If true, replace buffer_v[j] with the null terminator '\0'.
		  - Increment i by 1 to include the null terminator.
		  - Increment j by 1.
		  - Break the loop.
	   e. Copy data from buffer_v[j] to (*lineptr)[i].
	   f. Increment i by 1.
	   g. Increment j by 1.
	4. Check if i is 0 or bytes_read_v is 0.
	   - If true, return -1 to indicate no characters read or EOF.
	5. Return i - 1, the number of characters read excluding the null terminator.
		
	
Pseudocode
----------	
function name: _atoi_f
location: _atoi_f.c file
description: Convert a string to an integer.

Steps:
	1. Declare variables: num (unsigned int), sign (int).
	2. Set num to 0 and sign to 1.
	3. Start a do-while loop:
	   a. Check if the current character pointed by s is '-'.
		  - If true, multiply sign by -1 to toggle the sign.
	   b. Check if the current character pointed by s is a digit between '0' and '9'.
		  - If true, update num by multiplying it by 10 and adding the numeric value of the current digit.
	   c. Check if num is greater than 0.
		  - If true, break the loop to stop parsing further characters.
	   d. Increment the s pointer to the next character in the string.
	4. Continue the loop until *s is the null terminator '\0'.
	5. Return the result of num multiplied by sign.


Pseudocode
----------	
function name: _exit_f
location: _exit_f.c

description: Executes the exit command with the given arguments, exiting the program with the specified exit value.

Steps:
1. Declare a character array 'copy' with a size of 256.
2. Declare a character variable 'value'.
3. If the number of tokens 'cnt_v' is 2:
   a. Copy the second token from '(*tokens_v)' to 'copy' using _strcpy_f.
   b. Convert the copied string in 'copy' to an integer and assign it to 'value' using _atoi_f.
   c. Free the memory allocated for tokens using free_tokens2_f.
   d. If 'value' is equal to -1:
      i. Print an error message for 'copy' using print_error_f with error code 3.
      ii. Exit the program with a success status using exit(EXIT_SUCCESS).
   e. Exit the program with 'value' as the exit value.
4. Else if the number of tokens 'cnt_v' is greater than 2:
   a. Copy the second token from '(*tokens_v)' to 'copy' using _strcpy_f.
   b. Convert the copied string in 'copy' to an integer and assign it to 'value' using _atoi_f.
   c. Print "exit" using _puts_f.
   d. If 'value' is not equal to -1:
      i. Print an error message for "exit" using print_error_f with error code 2.
   e. Else if 'value' is equal to -1:
      i. Free the memory allocated for tokens using free_tokens2_f.
      ii. Print an error message for 'copy' using print_error_f with error code 3.
      iii. Exit the program with a success status using exit(EXIT_SUCCESS).
5. Else:
   a. Free the memory allocated for tokens using free_tokens2_f.
   b. Exit the program with a success status using exit(EXIT_SUCCESS).i


Pseudocode
----------	
function name: _cd_f
location: _cd_f.c

description: Changes the current directory of the process based on the provided arguments.

Steps:
1. Declare a character pointer 'path_v' and a character pointer 'buf_v'.
2. Declare a size_t variable 'buf_size_v' and initialize it to 512.
3. If the number of arguments 'size' is 1:
   a. Set 'path_v' to the value of the HOME environment variable.
4. Else if the number of arguments 'size' is 2:
   a. Set 'path_v' to the second argument from '(*args)'.
   b. If 'path_v' is equal to "-", set 'path_v' to the value of the OLDPWD environment variable.
      i. If 'path_v' is NULL:
         - Print an error message for "cd" using print_error_f with error code 4.
         - Return from the function.
5. Else (if more than 1 argument is passed):
   a. Print an error message for "cd" using print_error_f with error code 2.
   b. Return from the function.
6. Start a loop:
   a. Allocate memory for 'buf_v' with a size of 'buf_size_v' characters.
   b. If memory allocation fails:
      - Print an error message for "cd" using print_error_f with error code 1.
   c. Increase 'buf_size_v' by 100.
   d. Continue the loop if getcwd(buf_v, buf_size_v) returns NULL.
7. Set the value of the OLDPWD environment variable to 'buf_v' using setenv("OLDPWD", buf_v, 1).
   - If an error occurs, print an error message using perror().
8. Change the current directory to 'path_v' using chdir().
   - If an error occurs, print an error message for 'path_v' using print_error_f with error code 5 and free  memory allocated for `buf_v` then return from the function.
9. Set the value of the PWD environment variable to current working directory using setenv("PWD", getcwd(buf_v, buf_size_v), 1).
   - If an error occurs, print an error message using perror().
10. Free the memory allocated for 'buf_v'.


Pseudocode
----------	
function name: numberlen_f
location: _atoa_f.c file
description: Gets the length of a given number.

Steps:
  1. Declare variables: i_v (int) and initialize it to 0.
  2. Start a while loop:
     a. Check if num is not equal to 0.
        - If true, divide num by 10 and assign the result back to num.
        - Increment i_v by 1.
  3. Return the value of i_v as the length of num.
  
  
Pseudocode
----------
function name: rev_string_f
location: _atoa_f.c file
description: Reverse a given string.

Steps:
  1. Declare variables: l (int), i (int), tmp (char).
  2. Initialize l to 0.
  3. Iterate through the string s until the null terminator '\0' is encountered:
     a. Increment l by 1 for each character in s.
  4. Iterate from 0 to l / 2 (exclusive) using i:
     a. Swap the character at index i in s with the character at index (l - i - 1) in s using tmp as a temporary variable.
  5. The string s is now reversed.


Pseudocode
----------	
function name: _atoa_f
location: _atoa_f.c file
description: Converts an integer to a string.

Steps:
1. Declare a character pointer 'str_v' and allocate memory for it using malloc.
   - The size of the allocated memory should be equal to the length of the number converted to a string, obtained from the function 'numberlen_f'.
2. Declare an integer variable 'is_neg_v' and set it to 0.
3. Declare an integer variable 'i_v' and set it to 0.
4. Check if the input 'num' is equal to 0:
   a. If true, set the first character of 'str_v' to '0' and the second character to '\0'.
   b. Return 'str_v'.
5. Check if the input 'num' is less than 0:
   a. If true, set 'is_neg_v' to 1 and change 'num' to its absolute value by multiplying it by -1.
6. Start a loop:
   a. Set the current character of 'str_v' at index 'i_v' to the remainder of 'num' divided by 10, added to '0' to convert it to the corresponding character.
   b. Divide 'num' by 10.
   c. Increment 'i_v' by 1.
   d. Repeat steps a-c until 'num' becomes 0.
7. Check if 'is_neg_v' is true (1):
   a. If true, set the character at index 'i_v' of 'str_v' to '-'.
   b. Increment 'i_v' by 1.
8. Reverse the string 'str_v' using the function 'rev_string_f'.
9. Set the character at index 'i_v' of 'str_v' to '\0'.
10. Return 'str_v'.


Pseudocode
----------	
function name: slice_f
location: handle_variable_f.c file
description: Slices a given string.

Steps:
  1. Declare variables: i_v (unsigned int), j_v (unsigned int).
  2. Initialize j_v to 0.
  3. Iterate from start to end (inclusive) using i_v:
     a. Assign the character at index i_v in the string to buff at index j_v.
     b. Increment j_v by 1.
  4. Assign null terminator '\0' to buff at index j_v.


Pseudocode
----------	
function name: handle_variable_f
location: handle_variable_f.c file
description: Handles variables replacement.

Steps:
  1. Declare variables: command (pointer to string), buff (pointer to string),
     pid (pointer to string), value (pointer to string), size (unsigned int).
  2. Get the command from args and assign it to the command variable.
  3. Calculate the size of the command string using _strlen_f function and assign it to size.
  4. Check if the command is "echo" using _strcmp_f function. If not, return from the function.
  5. Allocate memory for buff with size + 1 bytes using malloc.
  6. Check if the size of the command is 2:
     a. If true, check the second character of the command:
        - If it is '?', get the value of the "EXIT_STATUS" environment variable using getenv.
          - If the value is NULL, print a newline character.
          - Otherwise, print the value followed by a newline character.
        - If it is '$', get the current process ID (PID) using _atoa_f and getpid functions.
          - Print the PID followed by a newline character.
          - Free the memory allocated for pid.
  7. If the size of the command is not 2:
     a. Slice the command string from index 1 to size + 1 using the slice_f function and store it in buff.
     b. Get the value of the environment variable with the name stored in buff using getenv.
        - If the value is NULL, print a newline character.
        - Otherwise, print the value followed by a newline character.
  8. Free the memory allocated for buff.
